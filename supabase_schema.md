### **Mnemoflow 后端上下文: 最终版数据库 Schema (V1.1 - 强化版)**

  

**文档版本**: 1.1  

**状态**: ✅ **已在生产数据库中激活并生效**

  

#### **核心目的**

  

本文档包含了 Mnemoflow 应用所有数据表的完整 SQL 定义和设计解析。

  

**请将此文件作为数据库结构的“唯一事实来源 (Single Source of Truth)”。** 所有后端的业务逻辑和数据操作都应基于此 Schema 进行。

  

#### **⚠️ 重要说明：关于 UNIQUE 约束**

  

此文档中描述的 SQL Schema 包含多个关键的 UNIQUE 约束（包括单字段和复合约束），这些约束对于保证数据一致性至关重要。由于可视化工具的限制，部分约束可能未在 ERD 图中明确标出。**当图表与本文档存在差异时，请以本文档中的 SQL 定义为准。**

  

#### **核心设计理念**

  

1. **用户中心化**: 所有用户数据都通过 auth.users 表的 id (UUID) 关联，并由行级安全 (RLS) 策略进行严格保护。

2. **动静分离**: 核心数据被拆分为两部分：几乎不变的**静态词典 (words)** 和由 AI 动态生成的**助记内容 (word_mnemonics)**。此架构极大地优化了性能和缓存效率。

3. **学习枢纽**: user_word_progress 表是整个学习系统的核心，它连接了用户、单词和学习状态，是实现 FSRS 算法的关键。

  

---

  

### **数据库完整 SQL 定义 (已包含约束说明)**

  

#### **0. 自动化工具: 自动更新 'updated_at' 时间戳的函数**

  

codeSQL

  

```

CREATE OR REPLACE FUNCTION public.handle_updated_at()

RETURNS TRIGGER AS $$

BEGIN

  NEW.updated_at = NOW();

  RETURN NEW;

END;

$$ LANGUAGE plpgsql;

```

  

---

  

#### **1. 用户与认证**

  

**profiles Table**

  

- **目的**: 存储与 auth.users 关联的应用特定用户信息和偏好设置。

  

codeSQL

  

```

CREATE TABLE public.profiles (

  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,

  email TEXT UNIQUE,

  default_word_list_id BIGINT, -- 外键约束在 word_lists 创建后添加

  updated_at TIMESTAMPTZ DEFAULT NOW()

);

```

  

---

  

#### **2. 核心内容 (动静分离)**

  

**words Table (静态)**

  

- **目的**: 存储权威的、几乎不变的基础词典数据。

  

codeSQL

  

```

CREATE TABLE public.words (

  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  word TEXT NOT NULL UNIQUE,

  definition JSONB,

  phonetic TEXT,

  tags TEXT[], -- 考试标签, e.g., '{"CET-4", "高考"}'

  created_at TIMESTAMPTZ DEFAULT NOW()

);

CREATE INDEX idx_words_on_word ON public.words(word);

```

  

**word_mnemonics Table (动态)**

  

- **目的**: 存储由 AI 动态生成的、可变的助记内容。

- **关键约束**: word_id 字段是 UNIQUE 的，这强制确保了一个单词 (word) 只能对应一条助记内容，构成了严格的**一对一关系**。

  

codeSQL

  

```

CREATE TABLE public.word_mnemonics (

  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  -- UNIQUE 约束强制实现与 'words' 表的一对一关系

  word_id BIGINT NOT NULL UNIQUE REFERENCES public.words(id) ON DELETE CASCADE,

  content JSONB NOT NULL, -- 结构: { blueprint, scene_segments }

  version INT DEFAULT 1,

  created_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,

  created_at TIMESTAMPTZ DEFAULT NOW(),

  updated_at TIMESTAMPTZ DEFAULT NOW()

);

CREATE INDEX idx_word_mnemonics_on_word_id ON public.word_mnemonics(word_id);

CREATE TRIGGER on_word_mnemonics_updated

  BEFORE UPDATE ON public.word_mnemonics

  FOR EACH ROW

  EXECUTE PROCEDURE public.handle_updated_at();

```

  

---

  

#### **3. 用户学习与管理**

  

**word_lists Table**

  

- **目的**: 存储用户创建的自定义单词本。

  

codeSQL

  

```

CREATE TABLE public.word_lists (

  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,

  name TEXT NOT NULL,

  created_at TIMESTAMPTZ DEFAULT NOW()

);

CREATE INDEX idx_word_lists_on_user_id ON public.word_lists(user_id);

  

-- 添加之前声明的外键约束

ALTER TABLE public.profiles

ADD CONSTRAINT fk_default_word_list

FOREIGN KEY (default_word_list_id)

REFERENCES public.word_lists(id)

ON DELETE SET NULL;

```

  

**user_word_progress Table (核心枢纽)**

  

- **目的**: 连接用户、单词和学习状态，存储 FSRS 算法所需的所有数据。

- **关键约束**: (user_id, word_id) 的组合是 UNIQUE 的。这确保了一个用户对于同一个单词只能有一条学习进度记录，是防止数据冗余和保证算法准确性的核心。

  

codeSQL

  

```

CREATE TABLE public.user_word_progress (

  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,

  word_id BIGINT NOT NULL REFERENCES public.words(id) ON DELETE CASCADE,

  word_list_id BIGINT REFERENCES public.word_lists(id) ON DELETE SET NULL,

  -- FSRS 核心字段

  stability REAL,

  difficulty REAL,

  due TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  lapses INTEGER DEFAULT 0,

  state INT DEFAULT 0,

  last_review TIMESTAMPTZ,

  created_at TIMESTAMPTZ DEFAULT NOW(),

  -- 核心约束: 确保一个用户对一个单词只有一条学习记录

  UNIQUE(user_id, word_id)

);

CREATE INDEX idx_user_word_progress_on_user_id ON public.user_word_progress(user_id);

CREATE INDEX idx_user_word_progress_on_word_id ON public.user_word_progress(word_id);

```

  

---

  

#### **4. 用户活动与反馈**

  

**mnemonic_feedback Table**

  

- **目的**: 收集用户对特定版本助记内容的反馈。

- **关键约束**: (user_id, word_mnemonic_id) 的组合是 UNIQUE 的。这确保了一个用户只能对一条助记内容提交一次反馈，避免了重复投票。

  

codeSQL

  

```

CREATE TABLE public.mnemonic_feedback (

  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,

  word_mnemonic_id BIGINT NOT NULL REFERENCES public.word_mnemonics(id) ON DELETE CASCADE,

  rating SMALLINT NOT NULL, -- e.g., 1 for helpful, -1 for not helpful

  created_at TIMESTAMPTZ DEFAULT NOW(),

  -- 核心约束: 确保用户对一个助记内容只能反馈一次

  UNIQUE(user_id, word_mnemonic_id)

);

CREATE INDEX idx_mnemonic_feedback_on_user_id ON public.mnemonic_feedback(user_id);

CREATE INDEX idx_mnemonic_feedback_on_word_mnemonic_id ON public.mnemonic_feedback(word_mnemonic_id);

```

  

**user_search_history Table**

  

- **目的**: 记录用户的单词查询历史。

- **关键约束**: (user_id, word_id) 的组合是 UNIQUE 的。这确保了一个用户的搜索历史中，一个单词只会出现一次。后续的搜索应更新 search_count 和 last_searched_at，而不是插入新行。

  

codeSQL

  

```

CREATE TABLE public.user_search_history (

  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,

  word_id BIGINT NOT NULL REFERENCES public.words(id) ON DELETE CASCADE,

  search_count INTEGER DEFAULT 1,

  last_searched_at TIMESTAMPTZ DEFAULT NOW(),

  -- 核心约束: 确保每个单词在用户历史中只有一条记录

  UNIQUE(user_id, word_id)

);

CREATE INDEX idx_user_search_history_on_user_id ON public.user_search_history(user_id);

```

  

**word_chat_history Table**

  

- **目的**: 存储用户与 AI 针对特定单词的对话历史。

  

codeSQL

  

```

CREATE TABLE public.word_chat_history (

  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,

  word_id BIGINT NOT NULL REFERENCES public.words(id) ON DELETE CASCADE,

  conversation_log JSONB, -- 结构: [{"role": "user", "content": "..."}, ...]

  updated_at TIMESTAMPTZ DEFAULT NOW()

);

CREATE INDEX idx_word_chat_history_on_user_id ON public.word_chat_history(user_id);

CREATE TRIGGER on_word_chat_history_updated

  BEFORE UPDATE ON public.word_chat_history

  FOR EACH ROW

  EXECUTE PROCEDURE public.handle_updated_at();

```